import { promises } from 'node:fs';
import { createHash } from 'node:crypto';
import { a as logger } from './nuxi.D5U3oSa9.mjs';
import { r as rmRecursive } from './nuxi.JWBOk7pn.mjs';
import { r as resolve, d as dirname } from './nuxi.Do0aYBCO.mjs';

function serialize(o){if(typeof o=="string")return `'${o}'`;const i=new l;return i.dispatch(o),i.serialized}const l=/*@__PURE__*/function(){class o{serialized="";#t=new Map;write(t){this.serialized+=t;}dispatch(t){return this["$"+(t===null?"null":typeof t)].call(this,t)}compare(t,r){return typeof t=="string"&&typeof r=="string"?t.localeCompare(r):serialize(t).localeCompare(serialize(r))}objectEntries(t,r){const e=Array.from(r).sort((n,a)=>this.compare(n[0],a[0]));this.write(`${t}{`);for(let n=0;n<e.length;n++){const[a,s]=e[n];this.write(`${a}:`),this.dispatch(s),n<e.length-1&&this.write(",");}this.write("}");}$string(t){this.write("'"+t+"'");}$symbol(t){this.write(t.toString());}$bigint(t){this.write(`${t}n`);}$object(t){const r=Object.prototype.toString.call(t);let e="";const n=r.length;n<10?e="unknown:["+r+"]":e=r.slice(8,n-1);let a=null;if((a=this.#t.get(t))===void 0)this.#t.set(t,this.#t.size);else return this.write(`#${a}`);if(e!=="Object"&&e!=="Function"&&e!=="AsyncFunction"){const s=this["$"+e];if(s)s.call(this,t);else {if(typeof t?.entries=="function")return this.objectEntries(e,t.entries());throw new Error(`Cannot serialize ${e}`)}}else {const s=t.constructor.name,c=s==="Object"?"":s;return typeof t.toJSON=="function"?(c&&this.write(c),this.$object(t.toJSON())):this.objectEntries(c,Object.entries(t))}}$function(t){const r=Function.prototype.toString.call(t);if(r.slice(-15)==="[native code] }")return this.write(`${t.name||""}()[native]`);this.write(`${t.name}(${t.length})${r.replace(/\s*\n\s*/g,"")}`);}$Array(t){this.write("[");for(const r of t)this.dispatch(r),this.write(",");this.write("]");}$Date(t){return this.write(`Date(${t.toJSON()})`)}$ArrayBuffer(t){this.write(`ArrayBuffer[${Array.prototype.slice.call(new Uint8Array(t)).join(",")}]`);}$Set(t){this.write("Set"),this.$Array(Array.from(t).sort((r,e)=>this.compare(r,e)));}$Map(t){return this.objectEntries("Map",t.entries())}}for(const i of ["boolean","number","null","undefined"])o.prototype["$"+i]=function(t){return this.write(t)};for(const i of ["Error","RegExp","URL"])o.prototype["$"+i]=function(t){return this.write(`${i}(${t.toString()})`)};for(const i of ["Uint8Array","Uint8ClampedArray","Unt8Array","Uint16Array","Unt16Array","Uint32Array","Unt32Array","Float32Array","Float64Array"])o.prototype["$"+i]=function(t){this.write(`${i}[${Array.prototype.slice.call(t).join(",")}]`);};return o}();

function digest(date) {
  return createHash("sha256").update(date).digest("base64url");
}

function hash(input) {
  return digest(serialize(input));
}

async function cleanupNuxtDirs(rootDir, buildDir) {
  logger.info("Cleaning up generated Nuxt files and caches...");
  await rmRecursive(
    [
      buildDir,
      ".output",
      "dist",
      "node_modules/.vite",
      "node_modules/.cache"
    ].map((dir) => resolve(rootDir, dir))
  );
}
function nuxtVersionToGitIdentifier(version) {
  const id = /\.([0-9a-f]{7,8})$/.exec(version);
  if (id?.[1]) {
    return id[1];
  }
  return `v${version}`;
}
function resolveNuxtManifest(nuxt) {
  const manifest = {
    _hash: null,
    project: {
      rootDir: nuxt.options.rootDir
    },
    versions: {
      nuxt: nuxt._version
    }
  };
  manifest._hash = hash(manifest);
  return manifest;
}
async function writeNuxtManifest(nuxt, manifest = resolveNuxtManifest(nuxt)) {
  const manifestPath = resolve(nuxt.options.buildDir, "nuxt.json");
  await promises.mkdir(dirname(manifestPath), { recursive: true });
  await promises.writeFile(manifestPath, JSON.stringify(manifest, null, 2), "utf-8");
  return manifest;
}
async function loadNuxtManifest(buildDir) {
  const manifestPath = resolve(buildDir, "nuxt.json");
  const manifest = await promises.readFile(manifestPath, "utf-8").then((data) => JSON.parse(data)).catch(() => null);
  return manifest;
}

export { cleanupNuxtDirs as c, loadNuxtManifest as l, nuxtVersionToGitIdentifier as n, resolveNuxtManifest as r, writeNuxtManifest as w };
